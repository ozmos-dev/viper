---
title: Routing
---
import {Aside, FileTree} from "@astrojs/starlight/components";
import FrameworkTabs from '../../../components/framework-tabs.astro'

Routes are registered both server side in Laravel and client side in your frameworks respective router ([react-router](https://reactrouter.com)/[vue-router](https://router.vuejs.org)). 

You can follow their respective documentations for more specific details on navigating your app. This page covers the Viper specific things you should know.

## Filesystem Routing

The following file structure is a comprehensive example of the routing capabilities:

<FrameworkTabs>
<Fragment slot="vue">
<FileTree>
  - resources
    - js
      - pages
        - _layout.vue
        - index.vue
        - blog
          - [...slug].vue
        - (auth)
          - _layout.vue
          - login.vue
          - register.vue
        - (app)
          - _layout.vue
          - home.vue
          - projects
            - _layout.vue
            - index.vue
            - [Project]
              - index.vue
              - edit.vue
</FileTree>
</Fragment>
<Fragment slot="react">
<FileTree>
  - resources
    - js
      - pages
        - _layout.tsx
        - index.tsx
        - blog
          - [...slug].tsx
        - (auth)
          - _layout.tsx
          - login.tsx
          - register.tsx
        - (app)
          - _layout.tsx
          - home.tsx
          - projects
            - _layout.tsx
            - index.tsx
            - [Project]
              - index.tsx
              - edit.tsx
</FileTree>
</Fragment>
</FrameworkTabs>

Generates the following routes:

- /
- /blog/\{slug}
- /login
- /register
- /home
- /projects
- /projects/\{project}
- /projects/\{project}/edit

Note that in React all pages must be exported as `default`.

## Config

Routes will be registered based on files placed in the `pages_path` config

```php
// config/viper.php

return [
  // ..
  'pages_path' => resource_path('js/pages'),
];
```

## Generated Code

A `${pages_path}/routes.ts` file is automatically generated for you which creates the types and route config necessary for the client side router to take over.

Do not modify this file.

## Navigating

See the framework specific documentation for navigating between pages

<FrameworkTabs>
<Fragment slot="vue">
https://router.vuejs.org/guide/essentials/navigation.html
</Fragment>
<Fragment slot="react">
https://reactrouter.com/start/framework/navigating
</Fragment>
</FrameworkTabs>


## Navigating to named routes

Navigate to named routes using the `route` helper provided by Viper.

<Aside>
  The route helper provided is a wrapper around `ziggy-js` but ensures all routes are relative by default.
</Aside>

<FrameworkTabs>
<Fragment slot="vue">
```vue
<template>
    <router-link :to="route('home')">Login</router-link>
</template>

<script setup lang="ts">
import { route } from '@/pages/routes';
</script>
```
</Fragment>
<Fragment slot="react">
```tsx
import { useNavigate } from "react-router";
import { route } from '@/pages/routes';

export default function Home() {
  const navigate = useNavigate();

  return <Link to={route('login')}>Login</Link>
}
```
</Fragment>
</FrameworkTabs>

To give a page a name, use the `Name` attribute on your class:

```php
// resources/js/pages/login.php
return new #[\Ozmos\Viper\Attrs\Name('login')] class {};
```

## Route Params

### Generic params

You can capture route params by using square brackets. The param must be camel cased, or it will be converted to camel case if not already.

```vue
// posts/[id].vue

<template>
    <h1>Post {{ id }}</h1>
</template>

<script setup lang="ts">
import { usePage } from '@ozmos/viper-vue';

const page = usePage<ViperGen.PostsIdParam>();
const { data: id } = page.useQuery('id');
</script>

<php>
return new class {
  #[\Ozmos\Viper\Attrs\Prop]
  public function id(string $id): string
  {
    return $id;
  }
};
</php>
```

### Route model binding

Models are automatically injected if a matching `\App\Models\{param}` class exists.

Multiword params like `[blogPost]` will be pascal cased to `BlogPost`.

```vue
// posts/[post].vue

<template>
    <h1>Post {{ post.title }}</h1>
</template>

<script setup lang="ts">
import { usePage } from '@ozmos/viper-vue';

const page = usePage<ViperGen.PostsIdParam>();
const { data: post } = page.useQuery('post');
</script>

<php>
return new class {
  #[\Ozmos\Viper\Attrs\Prop]
  public function post(\App\Models\Post $post)
  {
    return $post;
  }
};
</php>
```

You can configure model binding in your `AppServiceProvider`

```php
// app/Providers/AppServiceProvider.php

<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use Ozmos\Viper\Facades\Viper;

class AppServiceProvider extends ServiceProvider
{
  public function boot(): void
  {
    // this is the default -> enabled and looks for models in "\\App\\Models"
    Viper::autoDiscoverModels();

    // you can also configure a custom namespace to look in
    Viper::autoDiscoverModels("\\App\\V2\\Models");

    // or disable model discovery completely
    Viper::autoDiscoverModels(false);
  }
}

````

### Wildcard Routes

Wildcard routes are captured by prepending three periods before a param name such as `blog/[...slug].vue`.

Routes like `blog/2025/10/01/my-post` will capture a slug value of `2025/10/01/my-post`.

```vue
// blog/[...slug].vue
<template>
    <p>The captured path is {{ params.slug }}</p>
</template>

<script setup lang="ts">
import { usePage } from '@ozmos/viper-vue';

const { params } = usePage();
</script>
```

## Layouts

Layouts are vue files named `_layout.vue` and can be nested in each sub directory. They must always render a `<router-view></router-view>`.

These can be used for both providing a visual layout and providing props, middleware, etc to all subroutes.

```vue
<template>
  <!-- (app)/_layout.vue -->
  <nav>...</nav>
  <main>
    <router-view></router-view>
  </main>
</template>

<php>
return new
#[\Ozmos\Viper\Attrs\Name('app.')]
class {
  #[\Ozmos\Viper\Attrs\Prop]
  public function user(): \App\Dto\UserDto
  {
    return UserDto::from(request()->user());
  }
};
</php>
```

## Route Groups

Route groups are directories wrapped with parenthesis e.g. `(auth)` and do not reflect in the final url.

This is useful for providing shared layouts without affecting the url. For example, you can provide a layout for your auth routes without having to create a url like `/auth/login`.

## Route Names

Route names are provided via an attribute on the class.

```vue
// home.vue
<php>
return new
#[\Ozmos\Viper\Attrs\Name('home')]
class {};
</php>
```

Route names provided via layouts are prefixed **as-is** to subroutes.

```vue
// posts/_layout.vue
<php>
return new
// notice the "."
#[\Ozmos\Viper\Attrs\Name('posts.')]
class {};
</php>
```

```vue
// posts/index.vue
<php>
return new
// final name is posts.show
#[\Ozmos\Viper\Attrs\Name('show')]
class {};
</php>
```

## Middleware

Middleware is provided via a route attribute and applies to all subroutes, props, and actions.

```vue
// /app/_layout.vue
<php>
return new
#[\Ozmos\Viper\Attrs\Middleware(['auth'])]
class {};
</php>
```

## Page Titles

First ensure you have the head directive to your blade layout file. This directive inserts a `<title>` tag so double check that you do not already have one present.

```php
// app.blade.php

<head>
  @viperHead
</head>
```

You can provide the page title to use via both laravel and vue.

```vue
<php>
// set the server pages title
return new #[\Ozmos\Viper\Attrs\Title("Home")] class {};
</php>

<script setup lang="ts">
import { usePage } from '@ozmos/viper-vue';

// document.title is 'Home' right now
// we can also set the title client side afterwards if you want
usePage().replaceTitle("XYZ");
</script>
```

And you can configure a default title or custom format when configuring the plugin

```ts
// resources/js/app.ts
createApp({ render: () => "..." })
  // .use(...)
  .use(ViperPlugin, { formatTitle: title => title || 'Laravel' })
```


